//
// Created by machiry on 12/28/16.
//

#ifndef PROJECT_VULNERABILITYWARNING_H
#define PROJECT_VULNERABILITYWARNING_H

#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/IR/DebugLoc.h"
#include "llvm/Pass.h"
#include "llvm/PassAnalysisSupport.h"
#include "llvm/Analysis/AliasSetTracker.h"
#include "llvm/IR/InstVisitor.h"
#include "llvm/IR/CFG.h"
#include "../../../../Utils/include/CFGUtils.h"


using namespace llvm;
namespace DRCHECKER {
    /***
     * This represents a common class for all vulnerability warnings.
     */
    class VulnerabilityWarning {
    public:
        std::set<std::vector<InstLoc*>*> traces;
        std::vector<Instruction*> callSiteTrace;
        std::string warning_string;
        Instruction* target_instr;
        std::string found_by;

        VulnerabilityWarning(std::vector<Instruction*> *callTrace,
                            std::set<std::vector<InstLoc*>*> *srcTrace, std::string warningMsg,
                            Instruction *targetInstr, std::string found_by) {
            this->target_instr = targetInstr;
            this->warning_string = warningMsg;
            if (callTrace) {
                this->callSiteTrace.insert(this->callSiteTrace.end(), callTrace->begin(), callTrace->end());
            }
            if (srcTrace && !srcTrace->empty()) {
                //First append the warned inst to the trace.
                InstLoc *il = new InstLoc(this->target_instr,&this->callSiteTrace);
                bool inserted = false;
                for (std::vector<InstLoc*> *tr : *srcTrace) {
                    if (!tr) {
                        continue;
                    }
                    if (tr->size() == 0 || !il->same((*tr)[tr->size()-1])) {
                        tr->push_back(il);
                        inserted = true;
                    }
                }
                if (!inserted) {
                    delete(il);
                }
                this->traces.insert(srcTrace->begin(), srcTrace->end());
            }
            this->found_by = found_by;
        }

        //A wrapper for convenience and compatiability.
        VulnerabilityWarning(std::vector<Instruction*> *callTrace,
                             std::vector<InstLoc*> *srcTrace, std::string warningMsg,
                             Instruction *targetInstr, std::string found_by): 
                             VulnerabilityWarning(callTrace,(std::set<std::vector<InstLoc*>*>*)nullptr,warningMsg,targetInstr,found_by) {
            if (srcTrace) {
                //First append the warned inst to the trace.
                InstLoc *il = new InstLoc(this->target_instr,&this->callSiteTrace);
                if (srcTrace->size() == 0 || !il->same((*srcTrace)[srcTrace->size()-1])) {
                    srcTrace->push_back(il);
                }else {
                    delete(il);
                }
                //REcord the trace.
                this->traces.insert(srcTrace);
            }
        }

        /***
         * Print complete warning message to the provided raw stream.
         * @param O raw stream to which the output should be written to.
         */
        virtual void printCompleteWarning(llvm::raw_ostream& O) const;

        /***
         *  Print a normal warning message to the provided output stream.
         * @param O raw stream to which the output should be written to.
         */
        virtual void printWarning(llvm::raw_ostream& O);

        /***
         *  get the trace of the call sites to this function where the warning was
         *  generated.
         * @return pointer to the list of instruction representing call sites.
         */
        virtual std::vector<Instruction*> *getCallSiteTrace() {
            return &(this->callSiteTrace);
        }

        virtual bool isSameVulWarning(VulnerabilityWarning *toCheck) {
            if(toCheck != nullptr) {
                return this->target_instr == toCheck->target_instr &&
                       this->warning_string.compare(toCheck->warning_string) == 0 &&
                       this->found_by.compare(toCheck->found_by) == 0;
            }
            return false;
        }
    };
}

#endif //PROJECT_VULNERABILITYWARNING_H
